"GlobalSymm",
"LocalSymm",
"Score", # 0 to 5. Categorical
# 5 is perfect symmetry, 1 is not really symmetric
#0 not symmetric
"TrueSymmOri",
"DetectedSymm",
"Time"
)
#Transform the range of global and local symmetry from 0.5-1 to 0-1
dataset$GlobalSymm<- (dataset$GlobalSymm - min(dataset$GlobalSymm))/(max(dataset$GlobalSymm)-min(dataset$GlobalSymm))
dataset$LocalSymm<- (dataset$LocalSymm - min(dataset$LocalSymm))/(max(dataset$LocalSymm)-min(dataset$LocalSymm))
#Now add factors for variables that are factors
dataset<- na.omit(dataset)
dataset$SubjectNum <- as.factor(dataset$SubjectNum)
dataset$TrueSymmOri <- as.factor(dataset$TrueSymmOri)
dataset$DetectedSymm <- as.factor(dataset$DetectedSymm)
dataset$Score <- as.ordered(dataset$Score)
#Exclude the figures with no global symmetry which introduces noise
excludelocal<- dataset$DetectedSymm
excludelocal[dataset$GlobalSymm == 0] <- FALSE;
dataset<-cbind(dataset,excludelocal)
############################################################################
## Logistic regression
logistic <- glm(DetectedSymm ~ GlobalSymm + LocalSymm + TrueSymmOri, data=dataset, family="binomial")
summary(logistic)
#Model only taking into account Global Symmetry as independent variable
simple_logistic <- glm(excludelocal ~ GlobalSymm, data=dataset, family="binomial")
summary(simple_logistic)
#Predict maximum likelihood probabilities
GlobalSymm_range <- seq(from=min(dataset$GlobalSymm), to=max(dataset$GlobalSymm), by=.01)
GlobalSymm_slope <- simple_logistic$coefficients[2]
b0 <- simple_logistic$coefficients[1]
logits<- b0 + GlobalSymm_slope* GlobalSymm_range
probs <- exp(logits)/(1+exp(logits))
#Compute the experimental probabilities as the mean detection for each percentage of
#global symmetric points
means_tot=dataset %>%
group_by(GlobalSymm) %>%
summarize(
means_tot = mean(as.logical(DetectedSymm))
)
means_subjects=dataset %>%
group_by(SubjectNum,GlobalSymm) %>%
summarize(
means_subjects = mean(as.logical(DetectedSymm))
)
#Calculate the sd of intersubject variability
sd_tot= rep(0, 10)
for (i in 1:10) {
for (a in 1:length(means_subjects$GlobalSymm)){
if (means_tot$GlobalSymm[i] == means_subjects$GlobalSymm[a]) {
sd_tot[i] <- sd_tot[i] + (means_tot$means_tot[i] - means_subjects$means_subjects[a])**2 #Sum of Squares
}
}
sd_tot[i]= sqrt(sd_tot[i]/(length(means_subjects$GlobalSymm)-1)) #SD formula
}
#Plot of the probability of detection vs global symmetry
ggplot() +
geom_line(aes(x=GlobalSymm_range, y=probs))+
geom_point(aes(x=means_tot$GlobalSymm, y= means_tot$means_tot), size=2) +
geom_errorbar(aes(x=means_tot$GlobalSymm, y= means_tot$means_tot, ymin=means_tot$means_tot-sd_tot, ymax=means_tot$means_tot+sd_tot), width=.002,
position=position_dodge(.9)) +
xlab("% Global Symmetry") +
ylab("Probability of detecting the axis of symmetry")
setwd("D:/Github/Final-Grade-Project/Stadistics")
library(ggplot2)
library(cowplot)
library(R.matlab)
library(MASS)
library(dplyr)
library(reshape2)
############################################################################
## Load the data
#IMPORTANT
#Before running the code set as working directory to source file location
dir <- dirname(getwd())
file_list <- list.files(path=paste(c(dir,'/Stats/Results/'),  collapse = ''))
#initiate a blank data frame, each iteration of the loop will append the data from the given file to this variable
dataset <- data.frame()
#had to specify columns to get rid of the total column
for (i in 1:length(file_list)){
temp_data <- readMat(paste(c(dir,'/Stats/Results/',file_list[i]), collapse = ''))
temp_data <- temp_data$respMat
temp_data <- cbind(rep(i,40 ),temp_data)
dataset <- rbind(dataset, temp_data) #for each iteration, bind the new data to the building dataset
}
dataset$V6 <- dataset$V5 == dataset$V6
realscore <- dataset$V4
realscore[dataset$V6==FALSE]<- 0
dataset$V4 <- realscore;
###########################################################################
## Reformat the data
#Add column names
colnames(dataset) <- c(
"SubjectNum",
"GlobalSymm",
"LocalSymm",
"Score", # 0 to 5. Categorical
# 5 is perfect symmetry, 1 is not really symmetric
#0 not symmetric
"TrueSymmOri",
"DetectedSymm",
"Time"
)
#Transform the range of global and local symmetry from 0.5-1 to 0-1
dataset$GlobalSymm<- (dataset$GlobalSymm - min(dataset$GlobalSymm))/(max(dataset$GlobalSymm)-min(dataset$GlobalSymm))
dataset$LocalSymm<- (dataset$LocalSymm - min(dataset$LocalSymm))/(max(dataset$LocalSymm)-min(dataset$LocalSymm))
#Now add factors for variables that are factors
dataset<- na.omit(dataset)
dataset$SubjectNum <- as.factor(dataset$SubjectNum)
dataset$TrueSymmOri <- as.factor(dataset$TrueSymmOri)
dataset$DetectedSymm <- as.factor(dataset$DetectedSymm)
dataset$Score <- as.ordered(dataset$Score)
#Exclude the figures with no global symmetry which introduces noise
excludelocal<- dataset$DetectedSymm
excludelocal[dataset$GlobalSymm == 0] <- FALSE;
dataset<-cbind(dataset,excludelocal)
############################################################################
## Logistic regression
logistic <- glm(DetectedSymm ~ GlobalSymm + LocalSymm + TrueSymmOri, data=dataset, family="binomial")
summary(logistic)
#Model only taking into account Global Symmetry as independent variable
simple_logistic <- glm(excludelocal ~ GlobalSymm, data=dataset, family="binomial")
summary(simple_logistic)
#Predict maximum likelihood probabilities
GlobalSymm_range <- seq(from=min(dataset$GlobalSymm), to=max(dataset$GlobalSymm), by=.01)
GlobalSymm_slope <- simple_logistic$coefficients[2]
b0 <- simple_logistic$coefficients[1]
logits<- b0 + GlobalSymm_slope* GlobalSymm_range
probs <- exp(logits)/(1+exp(logits))
#Compute the experimental probabilities as the mean detection for each percentage of
#global symmetric points
means_tot=dataset %>%
group_by(GlobalSymm) %>%
summarize(
means_tot = mean(as.logical(DetectedSymm))
)
means_subjects=dataset %>%
group_by(SubjectNum,GlobalSymm) %>%
summarize(
means_subjects = mean(as.logical(DetectedSymm))
)
#Calculate the sd of intersubject variability
sd_tot= rep(0, 10)
for (i in 1:10) {
for (a in 1:length(means_subjects$GlobalSymm)){
if (means_tot$GlobalSymm[i] == means_subjects$GlobalSymm[a]) {
sd_tot[i] <- sd_tot[i] + (means_tot$means_tot[i] - means_subjects$means_subjects[a])**2 #Sum of Squares
}
}
sd_tot[i]= sqrt(sd_tot[i]/(length(means_subjects$GlobalSymm)-1)) #SD formula
}
#Plot of the probability of detection vs global symmetry
ggplot() +
geom_line(aes(x=GlobalSymm_range, y=probs))+
geom_point(aes(x=means_tot$GlobalSymm, y= means_tot$means_tot), size=2) +
geom_errorbar(aes(x=means_tot$GlobalSymm, y= means_tot$means_tot, ymin=means_tot$means_tot-sd_tot, ymax=means_tot$means_tot+sd_tot), width=.002,
position=position_dodge(.9)) +
xlab("% Global Symmetry") +
ylab("Probability of detecting the axis of symmetry")
library(ggplot2)
library(cowplot)
library(R.matlab)
library(MASS)
library(dplyr)
library(reshape2)
############################################################################
## Load the data
#IMPORTANT
#Before running the code set as working directory to source file location
dir <- dirname(getwd())
file_list <- list.files(path=paste(c(dir,'/Results/'),  collapse = ''))
#initiate a blank data frame, each iteration of the loop will append the data from the given file to this variable
dataset <- data.frame()
#had to specify columns to get rid of the total column
for (i in 1:length(file_list)){
temp_data <- readMat(paste(c(dir,'/Results/',file_list[i]), collapse = ''))
temp_data <- temp_data$respMat
temp_data <- cbind(rep(i,40 ),temp_data)
dataset <- rbind(dataset, temp_data) #for each iteration, bind the new data to the building dataset
}
dataset$V6 <- dataset$V5 == dataset$V6
realscore <- dataset$V4
realscore[dataset$V6==FALSE]<- 0
dataset$V4 <- realscore;
###########################################################################
## Reformat the data
#Add column names
colnames(dataset) <- c(
"SubjectNum",
"GlobalSymm",
"LocalSymm",
"Score", # 0 to 5. Categorical
# 5 is perfect symmetry, 1 is not really symmetric
#0 not symmetric
"TrueSymmOri",
"DetectedSymm",
"Time"
)
#Transform the range of global and local symmetry from 0.5-1 to 0-1
dataset$GlobalSymm<- (dataset$GlobalSymm - min(dataset$GlobalSymm))/(max(dataset$GlobalSymm)-min(dataset$GlobalSymm))
dataset$LocalSymm<- (dataset$LocalSymm - min(dataset$LocalSymm))/(max(dataset$LocalSymm)-min(dataset$LocalSymm))
#Now add factors for variables that are factors
dataset<- na.omit(dataset)
dataset$SubjectNum <- as.factor(dataset$SubjectNum)
dataset$TrueSymmOri <- as.factor(dataset$TrueSymmOri)
dataset$DetectedSymm <- as.factor(dataset$DetectedSymm)
dataset$Score <- as.ordered(dataset$Score)
#Exclude the figures with no global symmetry which introduces noise
excludelocal<- dataset$DetectedSymm
excludelocal[dataset$GlobalSymm == 0] <- FALSE;
dataset<-cbind(dataset,excludelocal)
############################################################################
## Logistic regression
logistic <- glm(DetectedSymm ~ GlobalSymm + LocalSymm + TrueSymmOri, data=dataset, family="binomial")
summary(logistic)
#Model only taking into account Global Symmetry as independent variable
simple_logistic <- glm(excludelocal ~ GlobalSymm, data=dataset, family="binomial")
summary(simple_logistic)
#Predict maximum likelihood probabilities
GlobalSymm_range <- seq(from=min(dataset$GlobalSymm), to=max(dataset$GlobalSymm), by=.01)
GlobalSymm_slope <- simple_logistic$coefficients[2]
b0 <- simple_logistic$coefficients[1]
logits<- b0 + GlobalSymm_slope* GlobalSymm_range
probs <- exp(logits)/(1+exp(logits))
#Compute the experimental probabilities as the mean detection for each percentage of
#global symmetric points
means_tot=dataset %>%
group_by(GlobalSymm) %>%
summarize(
means_tot = mean(as.logical(DetectedSymm))
)
means_subjects=dataset %>%
group_by(SubjectNum,GlobalSymm) %>%
summarize(
means_subjects = mean(as.logical(DetectedSymm))
)
#Calculate the sd of intersubject variability
sd_tot= rep(0, 10)
for (i in 1:10) {
for (a in 1:length(means_subjects$GlobalSymm)){
if (means_tot$GlobalSymm[i] == means_subjects$GlobalSymm[a]) {
sd_tot[i] <- sd_tot[i] + (means_tot$means_tot[i] - means_subjects$means_subjects[a])**2 #Sum of Squares
}
}
sd_tot[i]= sqrt(sd_tot[i]/(length(means_subjects$GlobalSymm)-1)) #SD formula
}
#Plot of the probability of detection vs global symmetry
ggplot() +
geom_line(aes(x=GlobalSymm_range, y=probs))+
geom_point(aes(x=means_tot$GlobalSymm, y= means_tot$means_tot), size=2) +
geom_errorbar(aes(x=means_tot$GlobalSymm, y= means_tot$means_tot, ymin=means_tot$means_tot-sd_tot, ymax=means_tot$means_tot+sd_tot), width=.002,
position=position_dodge(.9)) +
xlab("% Global Symmetry") +
ylab("Probability of detecting the axis of symmetry")
setwd("D:/Github/Final-Grade-Project/Stadistics")
dir
dir <- dirname(getwd())
dir
library(ggplot2)
library(cowplot)
library(R.matlab)
library(MASS)
library(dplyr)
library(reshape2)
############################################################################
## Load the data
#IMPORTANT
#Before running the code set as working directory to source file location
dir <- dirname(getwd())
file_list <- list.files(path=paste(c(dir,'/Stadistics/Results/'),  collapse = ''))
#initiate a blank data frame, each iteration of the loop will append the data from the given file to this variable
dataset <- data.frame()
#had to specify columns to get rid of the total column
for (i in 1:length(file_list)){
temp_data <- readMat(paste(c(dir,'/Stadistics/Results/',file_list[i]), collapse = ''))
temp_data <- temp_data$respMat
temp_data <- cbind(rep(i,40 ),temp_data)
dataset <- rbind(dataset, temp_data) #for each iteration, bind the new data to the building dataset
}
dataset$V6 <- dataset$V5 == dataset$V6
realscore <- dataset$V4
realscore[dataset$V6==FALSE]<- 0
dataset$V4 <- realscore;
###########################################################################
## Reformat the data
#Add column names
colnames(dataset) <- c(
"SubjectNum",
"GlobalSymm",
"LocalSymm",
"Score", # 0 to 5. Categorical
# 5 is perfect symmetry, 1 is not really symmetric
#0 not symmetric
"TrueSymmOri",
"DetectedSymm",
"Time"
)
#Transform the range of global and local symmetry from 0.5-1 to 0-1
dataset$GlobalSymm<- (dataset$GlobalSymm - min(dataset$GlobalSymm))/(max(dataset$GlobalSymm)-min(dataset$GlobalSymm))
dataset$LocalSymm<- (dataset$LocalSymm - min(dataset$LocalSymm))/(max(dataset$LocalSymm)-min(dataset$LocalSymm))
#Now add factors for variables that are factors
dataset<- na.omit(dataset)
dataset$SubjectNum <- as.factor(dataset$SubjectNum)
dataset$TrueSymmOri <- as.factor(dataset$TrueSymmOri)
dataset$DetectedSymm <- as.factor(dataset$DetectedSymm)
dataset$Score <- as.ordered(dataset$Score)
#Exclude the figures with no global symmetry which introduces noise
excludelocal<- dataset$DetectedSymm
excludelocal[dataset$GlobalSymm == 0] <- FALSE;
dataset<-cbind(dataset,excludelocal)
############################################################################
## Logistic regression
logistic <- glm(DetectedSymm ~ GlobalSymm + LocalSymm + TrueSymmOri, data=dataset, family="binomial")
summary(logistic)
#Model only taking into account Global Symmetry as independent variable
simple_logistic <- glm(excludelocal ~ GlobalSymm, data=dataset, family="binomial")
summary(simple_logistic)
#Predict maximum likelihood probabilities
GlobalSymm_range <- seq(from=min(dataset$GlobalSymm), to=max(dataset$GlobalSymm), by=.01)
GlobalSymm_slope <- simple_logistic$coefficients[2]
b0 <- simple_logistic$coefficients[1]
logits<- b0 + GlobalSymm_slope* GlobalSymm_range
probs <- exp(logits)/(1+exp(logits))
#Compute the experimental probabilities as the mean detection for each percentage of
#global symmetric points
means_tot=dataset %>%
group_by(GlobalSymm) %>%
summarize(
means_tot = mean(as.logical(DetectedSymm))
)
means_subjects=dataset %>%
group_by(SubjectNum,GlobalSymm) %>%
summarize(
means_subjects = mean(as.logical(DetectedSymm))
)
#Calculate the sd of intersubject variability
sd_tot= rep(0, 10)
for (i in 1:10) {
for (a in 1:length(means_subjects$GlobalSymm)){
if (means_tot$GlobalSymm[i] == means_subjects$GlobalSymm[a]) {
sd_tot[i] <- sd_tot[i] + (means_tot$means_tot[i] - means_subjects$means_subjects[a])**2 #Sum of Squares
}
}
sd_tot[i]= sqrt(sd_tot[i]/(length(means_subjects$GlobalSymm)-1)) #SD formula
}
#Plot of the probability of detection vs global symmetry
ggplot() +
geom_line(aes(x=GlobalSymm_range, y=probs))+
geom_point(aes(x=means_tot$GlobalSymm, y= means_tot$means_tot), size=2) +
geom_errorbar(aes(x=means_tot$GlobalSymm, y= means_tot$means_tot, ymin=means_tot$means_tot-sd_tot, ymax=means_tot$means_tot+sd_tot), width=.002,
position=position_dodge(.9)) +
xlab("% Global Symmetry") +
ylab("Probability of detecting the axis of symmetry")
library(ggplot2)
library(cowplot)
library(R.matlab)
library(MASS)
library(dplyr)
library(reshape2)
library("ggpubr")
library(nnet)
library(VGAM)
############################################################################
## Load the data
#IMPORTANT
#Before running the code set as working directory to source file location
dir <- dirname(getwd())
dir
library(ggplot2)
library(cowplot)
library(R.matlab)
library(MASS)
library(dplyr)
library(reshape2)
library("ggpubr")
library(nnet)
library(VGAM)
############################################################################
## Load the data
#IMPORTANT
#Before running the code set as working directory to source file location
dir <- dirname(getwd())
#Get the file list of all response matrices
file_list <- list.files(path=paste(c(dir,'/Stadistics/Results/'),  collapse = ''))
#initiate a blank data frame, each iteration of the loop will append the data from the given file to this variable
dataset <- data.frame()
#Build a dataset with all the responses
for (i in 1:length(file_list)){
temp_data <- readMat(paste(c(dir,'/Stadistics/Results/',file_list[i]), collapse = ''))
temp_data <- temp_data$respMat
temp_data <- cbind(rep(i,40 ),temp_data)
dataset <- rbind(dataset, temp_data) #for each iteration, bind the new data to the building dataset
}
#Store a boolean which indicates us if symmetry axis orientation has been perceived properly or not
dataset$V6 <- dataset$V5 == dataset$V6
#Assign a score of 0 to every image where the axis was not detected properly
realscore <- dataset$V4
realscore[dataset$V6==FALSE]<- 0
dataset$V4 <- realscore;
###########################################################################
## Reformat the data
#Add column names
colnames(dataset) <- c(
"SubjectNum",
"GlobalSymm",
"LocalSymm",
"Score", # 0 to 5. Categorical
# 5 is perfect symmetry, 1 is not really symmetric
#0 not symmetric
"TrueSymmOri",
"DetectedSymm",
"Time"
)
#Normalize range of global and local symmetry from 0.5 and 1 to 0 and 1
dataset$GlobalSymm<- (dataset$GlobalSymm - min(dataset$GlobalSymm))/(max(dataset$GlobalSymm) - min(dataset$GlobalSymm))
dataset$LocalSymm<- (dataset$LocalSymm - min(dataset$LocalSymm))/(max(dataset$LocalSymm)-min(dataset$LocalSymm))
#Now add factors for variables that are factors
dataset$Score <- as.ordered(dataset$Score) #ordered factor
dataset<- na.omit(dataset)
dataset$SubjectNum <- as.factor(dataset$SubjectNum)
dataset$TrueSymmOri <- as.factor(dataset$TrueSymmOri)
dataset$DetectedSymm <- as.factor(dataset$DetectedSymm)
################################################################################
#Test proportionality
#For choosing a model we have to test if the proportionality on odds is not violated on this data
#First we fit a model without ordinal information
cat("Multinomial logistic regression \n")
mod.multinom <-multinom(Score~GlobalSymm + LocalSymm + TrueSymmOri, data = dataset)
print(summary(mod.multinom, cor=F, Wald=T))
x1<-logLik(mod.multinom)
cat("Degrees of freedom Multinomial logistic regression \n")
print(df_of_multinom_model <- attributes(x1)$df)
#Then, the partial proportional odds model
cat("Proportional odds logistic regression\n")
mod.polr <- polr(Score~GlobalSymm + LocalSymm + TrueSymmOri, data=dataset)
print(summary(mod.polr))
x2<-logLik(mod.polr)
cat("Degrees of freedom Proportional Odds Logistic Regression \n")
print(df_of_polr_model <- attributes(x2)$df)
cat("Answering the question: Is proportional odds model assumption violated\n")
cat("P value for difference in AIC between POLR and Multinomial Logit model\n")
# abs since the values could be negative. That is negative difference of degrees of freedom would produce p=NaN
a= 1-pchisq(abs(mod.polr$deviance-mod.multinom$deviance),   abs(df_of_multinom_model-df_of_polr_model))
a
#As the p-value is almost 0, we can state that the residuals are statistically different
#So proportionality on odds can not be maintained
################################################################################
# CUMULATIVE LOGIT MODEL ASSUMED UNCONSTRAINED PARTIAL-PROPORTIONAL ODDS
#For fitting the data, we choose an ordinal model but without the proportinality on oddas assumption
nonpropfit<-vglm(Score~ GlobalSymm, data = dataset, family = cumulative(parallel = F ~ GlobalSymm + LocalSymm))
summary(nonpropfit)
#Create the predicted probabilities for each scoring in function of Global Symmetry
newdat <- data.frame(
GlobalSymm= seq(from = 0, to = 1, length.out = 1000))
newdat <- cbind(newdat, predict(nonpropfit, newdat, type = "response"))
lnewdat <- melt(newdat, id.vars = c("GlobalSymm"),
variable.name = "Score", value.name="Probability")
#Plot the predicted probabilities
predplot<-ggplot() +
geom_line(data=lnewdat, aes(x = GlobalSymm, y = Probability, colour = Score))+
theme(legend.position=c(1,1),
legend.direction="horizontal",
legend.justification=c(1, 0),
legend.key.width=unit(1, "lines"),
legend.key.height=unit(1, "lines"),
plot.margin = unit(c(5, 1, 0.5, 0.5), "lines"))+
xlab("% of Global Symmetry Signal")+
ylab("Probability")+ ylim(0,1)
#Compare the predicted probabilities with the actual experimental histogram of Scores
#Plot for score = 1
hist1<- ggplot(dataset[dataset$Score==1,])+
geom_histogram(aes(x= GlobalSymm*100,  y=..count../sum(..count..)),binwidth = 5)+
geom_line(data=lnewdat[lnewdat$Score==1,], aes(x = GlobalSymm*100, y = Probability))+
ggtitle("Distribution of probabilities of Score = 1")+
xlab("% of Global Symmetry Signal")+
ylab("Probability")+ ylim(0,1)
#Plot for score = 2
hist2<- ggplot(dataset[dataset$Score==2,])+
geom_histogram(aes(x= GlobalSymm*100,  y=..count../sum(..count..)),binwidth = 5)+
geom_line(data=lnewdat[lnewdat$Score==2,], aes(x = GlobalSymm*100, y = Probability))+
ggtitle("Distribution of probabilities of Score = 2")+
xlab("% of Global Symmetry Signal")+
ylab("Probability")+ ylim(0,1)
#Plot for score = 3
hist3<- ggplot(dataset[dataset$Score==3,])+
geom_histogram(aes(x= GlobalSymm*100,  y=..count../sum(..count..)),binwidth = 5)+
geom_line(data=lnewdat[lnewdat$Score==3,], aes(x = GlobalSymm*100, y = Probability))+
ggtitle("Distribution of probabilities of Score = 3")+
xlab("% of Global Symmetry Signal")+
ylab("Probability")+ ylim(0,1)
#Plot for score = 4
hist4 <- ggplot(dataset[dataset$Score==4,])+
geom_histogram(aes(x= GlobalSymm*100,  y=..count../sum(..count..)),binwidth = 5)+
geom_line(data=lnewdat[lnewdat$Score==4,], aes(x = GlobalSymm*100, y = Probability))+
ggtitle("Distribution of probabilities of Score = 4")+
xlab("% of Global Symmetry Signal")+
ylab("Probability")+ ylim(0,1)
#Plot for score = 5
hist5 <- ggplot(dataset[dataset$Score==5,])+
geom_histogram(aes(x= GlobalSymm*100,  y=..count../sum(..count..)),binwidth = 5)+
geom_line(data=lnewdat[lnewdat$Score==5,], aes(x = GlobalSymm*100, y = Probability))+
ggtitle("Distribution of probabilities of Score = 5")+
xlab("% of Global Symmetry Signal")+
ylab("Probability")+ ylim(0,1)
#Merge all the plots on a single figure
histcomboplot <- ggarrange(hist1, hist2,hist3,hist4,hist5,
labels = c("A", "B","C","D",'E'),
ncol = 2, nrow = 3)
predplot
histcomboplot
